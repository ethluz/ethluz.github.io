{"data":{"markdownRemark":{"id":"edee68f8-b402-5b03-a56d-7996616bde20","html":"<p>大家知道客户端在调取智能合约时，需要先传递一个ABI接口。这样客户端（例如js）就可以调取智能合约中的方法了。</p>\n<p>那么在solidity中如何在当前编写的合约中调取一个已部署的合约呢？也类似，通过声明已部署的合约接口，让当前合约识别老合约。</p>\n<h4 id=\"第一种实现，通过接口调用：\"><a href=\"#%E7%AC%AC%E4%B8%80%E7%A7%8D%E5%AE%9E%E7%8E%B0%EF%BC%8C%E9%80%9A%E8%BF%87%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%EF%BC%9A\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>第一种实现，通过接口调用：</h4>\n<p><strong>合约调取合约最小实现案例</strong>\n<strong>第一个合约：</strong>\npragma solidity ^0.4.24;\ncontract Deployed {\nuint public a = 1;\n<br>\nfunction setA(uint _a) public returns (uint) {\na = _a;\nreturn a;\n}\n<br>\n}\n我们部署它，会得到一个合约地址，假设它是“0xxxxx”</p>\n<p><strong>我们写第二个合约：</strong>\npragma solidity ^0.4.24;</p>\n<p>//Deployed合约的接口\ninterface Deployed {\nfunction setA(uint) public returns (uint) {}\nfunction a() public pure returns (uint) {}\n<br>\n}</p>\n<p>contract Existing  {\n\nDeployed dc;\n\nfunction Existing(address <em>t) public {\ndc = Deployed(</em>t);\n}</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function getA() public view returns (uint result) {\n\treturn dc.a();\n}\n\nfunction setA(uint _val) public returns (uint result) {\n\tdc.setA(_val);\n\treturn _val;\n}</code></pre></div>\n<p>}</p>\n<p>如上面的代码，我们先声明了一个已部署合约的接口:\ninterface Deployed {\nfunction setA(uint) public returns (uint) {}\nfunction a() public pure returns (uint) {}\n} </p>\n<p>然后就可以在新的合约“Existing”中调用这个合约了。\n我们把第二个合约部署时，把第一个合约Deployed的合约地址“0xxxxx”传进来赋值给_t ，并初始化将第一个合约赋值给dc。我们看到getA,setA分别发生了什么？</p>\n<p>然后我们分别调取合约1和合约2，再去比较。</p>\n<p><strong>那么如何用solidity合约调取erc20代币的合约呢？</strong>\n比如snt啊，loom啊，knc啊。\n首先我有一个名叫loom的erc20token部署在ropsten网络。\nloom的详细：\n合约地址：0x090652a4aecee28a7ae766c5bd51851830185664\n[https://ropsten.etherscan.io/token/0x090652a4aecee28a7ae766c5bd51851830185664]</p>\n<p>我们写当前的合约向第一个例子一样，先写erc20token的接口，接着写我们调用的合约：\npragma solidity ^0.4.24;</p>\n<p>interface Tokenloom {\nfunction transfer(address to, uint256 value) external returns (bool success);\n}</p>\n<p>contract StandardToken{\nfunction transferloomtoken(uint256 amount){\nTokenloom token = Tokenloom(0x090652a4aecee28a7ae766c5bd51851830185664);\n//发送到token\ntoken.transfer(0xafe28867914795bd52e0caa153798b95e1bf95a1, amount);\n<br>\n}\n}</p>\n<p>我们将这个合约部署：\n同样在ropsten测试网中，得到这个合约地址：0x2C8C3483Be1160A2D89D07708b5477Ea19457255\n[https://ropsten.etherscan.io/address/0x2c8c3483be1160a2d89d07708b5477ea19457255]</p>\n<p>然后我们转入一笔loom到这个合约地址0x2C8C3483Be1160A2D89D07708b5477Ea19457255</p>\n<p>恩，我们看看转账记录：\n(img)\n[https://ropsten.etherscan.io/tx/0xaa5331f64eb7fee27f88a78254fd5f8772846aa4eb6dcb1c1d6a0eeb786d65da]</p>\n<p>接下来，我们调取我们所写的StandardToken合约的transferloomtoken这个方法，神奇的事又发生了：\n(img)\n[https://ropsten.etherscan.io/tx/0x1c37b517d32db95ebb059e6680882e825a897281965961c0593b862d810800fd]</p>\n<p>这种通过接口调用方式是最为推荐的，当然还有第二种：</p>\n<h4 id=\"第二种方式：使用call，delegatecall\"><a href=\"#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A%E4%BD%BF%E7%94%A8call%EF%BC%8Cdelegatecall\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>第二种方式：使用call，delegatecall</h4>\n<p>pragma solidity ^0.4.18;\ncontract ExistingWithoutABI  {\n<br>\naddress dc;\n<br>\nfunction ExistingWithoutABI(address <em>t) public {\ndc = _t;\n}\n<br>\nfunction setA</em>Signature(uint <em>val) public returns(bool success){\nrequire(dc.call(bytes4(keccak256(\"setA(uint256)\")),</em>val));\nreturn true;\n}\n}\n关于call的用法可参考solidity官方文档。</p>\n<p>原文地址：[https://medium.com/@blockchain101/calling-the-function-of-another-contract-in-solidity-f9edfa921f4c]</p>\n<h4 id=\"补充loom的教程：与其他合约的交互\"><a href=\"#%E8%A1%A5%E5%85%85loom%E7%9A%84%E6%95%99%E7%A8%8B%EF%BC%9A%E4%B8%8E%E5%85%B6%E4%BB%96%E5%90%88%E7%BA%A6%E7%9A%84%E4%BA%A4%E4%BA%92\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>补充loom的教程：与其他合约的交互</h4>\n<p><em>1.定义interface</em></p>\n<p>如果我们的合约需要和区块链上的其他的合约会话，则需先定义一个 interface (接口)。\n先举一个简单的栗子。 假设在区块链上有这么一个合约：\ncontract LuckyNumber {\nmapping(address => uint) numbers;</p>\n<p>  function setNum(uint _num) public {\nnumbers[msg.sender] = _num;\n}</p>\n<p>  function getNum(address <em>myAddress) public view returns (uint) {\nreturn numbers[</em>myAddress];\n}\n}</p>\n<p>这是个很简单的合约，您可以用它存储自己的幸运号码，并将其与您的以太坊地址关联。 这样其他人就可以通过您的地址查找您的幸运号码了。\n现在假设我们有一个外部合约，使用 getNum 函数可读取其中的数据。\n首先，我们定义 LuckyNumber 合约的 interface ：\ncontract NumberInterface {\nfunction getNum(address _myAddress) public view returns (uint);\n}</p>\n<p>请注意，这个过程虽然看起来像在定义一个合约，但其实内里不同：</p>\n<p>首先，我们只声明了要与之交互的函数 —— 在本例中为 getNum —— 在其中我们没有使用到任何其他的函数或状态变量。</p>\n<p>其次，我们并没有使用大括号（{ 和 }）定义函数体，我们单单用分号（;）结束了函数声明。这使它看起来像一个合约框架。</p>\n<p>编译器就是靠这些特征认出它是一个接口的。</p>\n<p>在我们的 app 代码中使用这个接口，合约就知道其他合约的函数是怎样的，应该如何调用，以及可期待什么类型的返回值。</p>\n<p>在下一节中，我们将真正调用其他合约的函数。目前我们只要声明一个接口，用于调用 CryptoKitties 合约就行了。</p>\n<p><em>2.使用接口，调用已用合约方法</em></p>\n<p>继续前面 NumberInterface 的例子，我们既然将接口定义为：\ncontract NumberInterface {\nfunction getNum(address _myAddress) public view returns (uint);\n}</p>\n<p>我们可以在合约中这样使用：\ncontract MyContract {\naddress NumberInterfaceAddress = 0xab38...;\n// ^ 这是FavoriteNumber合约在以太坊上的地址\nNumberInterface numberContract = NumberInterface(NumberInterfaceAddress);\n// 现在变量 <code class=\"language-text\">numberContract</code> 指向另一个合约对象</p>\n<p>  function someFunction() public {\n// 现在我们可以调用在那个合约中声明的 <code class=\"language-text\">getNum</code>函数:\nuint num = numberContract.getNum(msg.sender);\n// ...在这儿使用 <code class=\"language-text\">num</code>变量做些什么\n}\n}</p>\n<p>通过这种方式，只要将您合约的可见性设置为public(公共)或external(外部)，它们就可以与以太坊区块链上的任何其他合约进行交互。</p>","fields":{"slug":"/blog/smartcontract/solidity-2018.5.21/"},"headings":[{"value":"第一种实现，通过接口调用：","depth":4},{"value":"第二种方式：使用call，delegatecall","depth":4},{"value":"补充loom的教程：与其他合约的交互","depth":4}],"frontmatter":{"date":"December 17, 2018","title":"Solidity当前合约调取一个已部署合约&调取erc20代币合约的方法","description":"当前文章中上基于合约接口合约实现，当然也有简单写call，delegatecall的实现","tags":["solidity","区块链","以太坊"]}}},"pageContext":{"id":"edee68f8-b402-5b03-a56d-7996616bde20"}}